---
title: '软件工程知识点归纳'
description: '针对887考点的知识点的归纳总结'
pubDate: 'Aug 29 2023'
heroImage: '/SE.png'
---

## 软件工程概述

### 软件危机

定义：软件危机是指在计算机软件的开发和维护过程中所遇到的一系列严重问题。

原因 
 - 技术原因：软件规模大，软件复杂度高
 - 管理原因：软件开发缺乏正确的理论指导

如何克服软件危机：软件工程

软件开发链条的放大作用：
- 只有早期发现问题，才会尽量减少损失
- 客观规律：用户的牙膏不会一下子挤完（用户的需求是不断变化的）

#### 消除软件危机的途径

对计算机软件正确认知
- 技术和方法
- 软件工具
- 管理措施

软件工程
- 方法
- 工具
- 过程

软件
- 文档
- 程序
- 数据

软件工程是从**技术和管理**两方面研究如何更好地开发和维护计算机软件的一门新兴学科

软件工程的主要目标：高效开发高质量软件，降低开发成本

> 软件工程基本原理
> 1. 用分阶段的生命周期计划严格管理
> 2. 坚持进行阶段评审
> 3. 实行严格的产品控制
> 4. 采用现代程序设计技术
> 5. 结果应能清楚地审查
> 6. 开发小组的人员应该少而精
> 7. 承认不断改进软件工程实践的必要性

### 系统工程

目的：使得人们能够确保在正确的时间使用了正确的方法在做正确的事情

#### 统一建模语言（UML）

提供了一整套对系统建模的基础设施

**是一种工具而不是一种方法**

重要功能：可视化，规格说明，构造，文档化


UML的构成和视图：

1. 逻辑视图
2. 进程视图
3. 开发视图
4. 物理视图
5. 用例视图*

### 基于UML的系统开发过程

- 需求分析
- 分析和设计
- 软件架构建模
- 实现

#### 软件工程开发方法

三个要素
- 方法
    完成软件开发各项人物的**技术**，回答“如何做”
- 工具
    为方法的运用提供**自动或半自动软件支撑环境**，回答“用什么做”
- 过程
    为获得高质量的软件要完成的一系列任务的框架，规定完成各项任务的步骤，回答“如何控制，协调，保证质量”

分类：传统的和面向对象的

### 面向对象

特点
1. 尽可能**模拟人类习惯的思维方式**
2. 是一个**主动**地多次**反复迭代**的过程
3. 概念和表示方法上的**一致性，阶段间平滑过渡**
4. 由特殊到一般的**归纳**思维过程，由一般到特殊的**演绎**思维过程
5. 降低复杂性，提高可理解性
6. 促进了**软件重用**

## 软件开发过程

### 软件生命周期与开发过程

软件生命周期：更一般化

软件开发过程：更具体化

上名周期是软件开发宏观上的框架

### 软件生命周期的划分

- 软件定义
- 软件开发
- 运行维护

#### 可行性分析与开发计划

分析是否值得开发，**给决策者提供做与不做的依据**（*高层次的需求分析和设计*）

方面：
- 技术可行性
- 经济可行性
- 社会可行性

输出：描述可行性，拟定开发计划

#### 需求分析

确定软件开发可行的情况下，对目标软件未来需要完成的功能进行详细的分析

由于用户的需求随着项目的进展和理解处在不断的变化之中，应对需求进行**变更管理**

需求：
- 功能性需求
- 非功能性需求

输出：需求规格说明书

#### 软件设计

软件设计是在需求分析的基础上寻求系统求解的框架，如系统的架构设计、数据设计等。

分类：
- 概要设计
  
    输出：概要设计说明书

- 详细设计

    输出：详细设计说明书

尽可能保证系统设计结构在整体上的稳定性

#### 程序编码

要忠于设计

#### 软件测试

程序编码后需要对**代码**进行严密的测试，以发现 软件在整个设计过程中存在的问题并加以纠正。

阶段：
- 单元测试
- 集成测试
- 系统测试（包括验收测试）

测试方法：
- 黑盒方法
- 白盒方法

#### 软件维护

特点：**时间最长**+**成本最高**

分类
- 改正性维护（成本最高）
- 适应性维护
- 完善性维护
- 预防性维护

### 传统的软件生命周期模型

最基本和有效的可供选择的软件开发模型。

#### 瀑布模型

现在仍然是应用得**最广泛的**过程模型。

特点：
- 阶段间具有顺序性和依赖性，**文档驱动**
- 推迟实现，不急于编写代码
- 质量保证的观点

每个阶段都**必须完成规定的文档**，没有交出合格的文档就是没有完成该阶段的任务。

##### 实际的瀑布模型

可以在一定程度上解决变化的问题

**计划驱动** 在对系统整体的把控和协调上，具有优势，因此适合规模较大的系统或分布式开发模式。

#### 快速原型模型

快速原型模型(Rapid Prototype)的主要作用是在用户和 开发者之间起到“桥梁”的作用。

目的：降低风险

特点
1. 对系统进行简单和快速的分析，快速构造一个软件原型。
2. 反复评价和改进模型，获取用户真正的需求
3. 可以尝试未来的**新技术**

问题
- 原型和产品开发技术和手段不一样
- 原型一般会被抛弃

#### 增量模型

软件产品作为一系列增量构件来设计、编码、集成和测试。

- 瀑布模型:力求一次性给用户完整的系统。
- 增量模型:逐步增加系统功能。
- 需要开放的架构设计。

区分：快速原型在生命周期**头部**添加原型，增量模型在**尾部**添加功能增量

#### 螺旋模型

每个阶段前都增加了风险分析的快速原型模型

基本思想：使用原型及其它方法 **尽量降低⻛险**。

#### 喷泉模型

🌟特性：迭代+无缝
- 迭代：逐步求精，由小及大
- 无缝：设计与编码之间对应更好

为避免喷泉模型的过分无序，把一个线性过程作为总目标。

#### 敏捷软件开发

开发团队和用户反馈推动产品开发（强调与客户的合作）

- 增量的开发方式

  分批分期地交付用户产品，**先实现必要性的用户用例**

  用例：一件用户通过系统完成的有价值的目标，不是一个具体的功能

- 迭代的开发方式

  *不强调新功能的加入，是追求细化的过程*

  不指望构建的软件是客户想要的，先构建后修改（**逐步求精**），多次反复找到客户需要的软件

##### 极限编程（XP）

主要目的：降低需求变化的成本

##### SCRUM过程

XP注重实践，SCRUM注重过程。

- 需求——产品需求积压
- 开发过程——多个冲刺

角色

1. 产品拥有者：确定产品积压的优先级，开发团队和客户的联络点
2. 利益相关者：客户代表
3. 专家：开发团队和产品拥有者的联络点

##### DevOps过程

强调开发和运维之间必须紧密合作

是一组 **过程，方法与系统** 的统称

核心目标：自动化和可持续交互

- 持续集成

  提交新代码后立即构建单元测试以确定能否集成

  1. 纵向集成：应用全生命周期
  2. 横向集成：打通了架构，开发，管理，运维等部门

- 持续交付

  持续集成的延伸

  集成后的代码&rarr;类生产环境&rarr;生产环境

## 需求分析

目标：系统是什么，以及存在哪些约束条件。

挑战：
1. 分析人员需要*熟悉，了解和掌握相关的业务领域*
2. 每个人对于系统的全局都是一个局部
3. 如何采取措施应对客户想法的变化

### 可行性分析

给出系统一个合理可行的方案。

评估出系统初步的开发费用。

需求列表：
- 由客户主导制定的需求文档称为**用户（业务）需求**
    > 阅读对象是委托方和客户。
- 由开发者主导制定的需求文档称为**系统需求**
    > 系统需求是对用户需求的细化和完善
    > 是用户需求的开始

#### 涉众（Stakeholder）

是与目标系统相关的一切人和物
- 最终用户（直接涉众）：系统的直接使用者
- 投资者
- 业务提出者
- 业务管理者
- 业务执行者

##### 访谈

目标产物：规格说明
分类：
- 正式： 系统分析员提出事先准备好的问题
- 非正式：开放性场景

##### 用例

识别角色——>帮助寻找用例
> 角色是存在于系统 **边界之外** 的
> 角色可以是人，也可以是其他软件系统 eg.“定时器(Timer)“

寻找用例
1. 关键业务实体：关键概念或技术术语
2. 基本业务实体的加工和组合
3. 系统业务的利用和计算
4. 与其他系统的交互

分类
- 业务用例：从客户角度出发
- 系统用例：从计算机系统角度出发

用例规约

1. 处理流程：
    **基本事件流**:正常执行（include）
    **备选事件流**:异常或特殊情况（extend）
2. 关键性：该功能在系统中的关键程度（功能性需求）
3. 关联用例：其他相关用例（非功能性需求）

🌟**包含关系**

依赖：虚线+简单箭头

通用过程定义其主用例的 *基础性的功能*

构造型 << include >> 的关系与依赖它的主用例相连（指向基础用例）

💫主用例和包含用例应是平行关系，而非逻辑分解(粒度水平及抽象级别相等)

🌟**拓展关系**

在某些 *特殊情况* 下的处理

箭头方向指向主用例

- 般来说被包含用例属于无条件发生的用 例,而扩展用例属于有条件发生的用例;
- 被包含用例提供的是间接服务，扩展用例提供的是直接服务;
- 而且扩展用例在用例规约中一般作为基本事件的备选流而存在。

即使是在非常复杂的系统中，每个用例图中的用例数目一
般要避免超过 **15** 个。

#### 活动图

控制流：直线+简单箭头

开始，结束：实点●，实心点◉

action：圆角矩形

branch：菱形♢ + 条件[]

fork：分支

merge：分支合并+分支的关系{}

对象：矩形

activity：action的集合

泳道技术（swinlane）：将活动组织成用线分开的不同区域来表示

#### 功能性需求

1. 系统功能需求
   
    是系统功能的主要组成部分，也是另外两类需求功能的发起者

2. 交互需求

    提供数据的输入

3. 外部接口需求

#### 数据流图（DFD）

🌟画图重点

> 要点
> 1. 信息流不能是动词
> 2. 实体到实体的信息流动
> 3. 处理要有输入输出
> 4. 处理名不能是名词

分层细化时要注意层与层之间的连续性与一致性

#### 非功能性需求

#### 需求验证

验证需求一致性

- 自然语言书写（大部分）
- 形式化描述：使用软件工具

#### 需求跟踪

给出针对每个源需求及对应目标实现，将它们通过某种方式联系起来。

实践中常采用 **需求跟踪矩阵（RTM）** 对变更进行管理。

## 软件架构的构建

软件架构也被称为 *软件体系结构*

软件架构的"4+1"视图

> UML的构成和视图：
>
> 1. 逻辑视图
> 2. 进程视图
> 3. 开发视图
> 4. 物理视图
> 5. 用例视图*

架构的模型:结构模型、框架模型、动态模型、过程模型和功能模型

### 软件架构的基本元素

构建：软件模板单元

连接件：构建之间的交互

配置：构建与连接件之间的拓扑约束

### 常见体系结构风格

数据流⻛格：管道与过滤器

调用/返回⻛格：层次结构、正交软件结构、客 户机/服务器结构、浏览器/服务器结构

独立构件⻛格：MVC结构

数据中心⻛格：仓库/黑板系统

#### 管道与过滤器

特点：构件读取输入的数据流，产生输出的数据流

构件被称为过滤器

可以使软件具有良好的信息隐藏性和模块独立性，从而产生高内聚、低耦合的特点

#### 层次系统

特点：每一层为上一层服务，并作为其下层客户

优点：允许将一个复杂的问题分解成一个增量步骤序列的实现

#### 仓库系统

特点：中央数据结构+若干个独立构件

由控制原则分出的子类：

- 传统型数据库：仓库输入流中的事件触发进程
- 黑板系统：由中央数据结构的状态触发进程

优点：松耦合代理数据存取

#### 正交软件架构

构成：层和线索

- 层是一组具有相同抽象级别的构件构成
- 线索是子系统的特例

特点：不同线索之间没有相互调用

优点：每个需求变动仅影响某一条线索

#### 客户机/服务机架构 C/S

服务器：访问与并发性控制、安全性、备份与恢复和全局数据完整性规则。

客户机：提供界面、提交信息、客户端应用逻辑（胖客户）

优点：

- 对于硬件和软件的变化具有极大的适应性和灵活性
- 易于对系统进行扩充和缩小
- 系统中的功能构件充分隔离

#### 浏览器/服务器架构 B/S

是 C/S 的拓展瘦客户

可以减轻安装、配置、升级工作

优点：层与层之间相互独立，可选择任何厂家的产品（平台透明性）

缺点：应用服务器更新成本高 → 微服务技术

#### MVC架构

模型——视图——控制器

优点：在改进和个性化定制界面及用户交互时不需要重新编写用户逻辑。

### 软件结构设计

系统将逻辑关系密切的单元划分到一起，形成系统的逻辑划分（基于类模型进行）

将软件使用”包（package）“进行构造。

#### 包及其结构

包与包之间相互嵌套构成包的层次关系：直接嵌套或者通过一个带圈的十字连接符嵌套。

包之间的虚线箭头表示 **依赖关系**

包图中的一个重要的要求是在包间 **不能出现循环依赖**

#### 包结构设计

尽量减少包中全局类的数量

要将类更加合理地在包之间划分和组织，以提高各部分的独立性，从而达到更高的内聚性

调整包的宏观结构

## 类的分析与设计

对未来系统的功能进行总体上的概括并使用 UML 的类图进行表达

### 基本类的确定

类通常分为 **实体类、控制类和边界类**

实体类 → 名词

控制类（管理类） → 动宾

边界类 → 外部用户与系统之间的交互对象

#### 类的关系

关联关系( Assosiation )：最常见的关系,表达对象之间的一种“持有”联系

一个类可以具有只想自己本身的关联关系，称为 **自反关联**

#### 类与对象

对象在UML中通常使用 “对象名：类名” + 下划线来表示

### 类的细化

#### 管理类和控制类

管理类：同类对象的协调和管理 eg. BoolList 类

控制类：对一个或几个用力所特有的行为进行建模 eg. controller

建模建议：

1. 每次只考虑一个任务

2. 类与类之间尽可能保持较少的联系

#### 设计优化

有关章节详细论述

### 补充和确认

使用 UML 中的顺序图对需求场景中涉及的不同对象之间的交互过程进行建模

#### 顺序图

横轴：场景中所涉及的对象横向罗列

纵轴：时间的延续

每个对象的生命线：每个对象垂直向下延伸的虚线

同步消息：实心三角箭头表示 →

异步消息：简单箭头

对象的创建和消息的返回：虚线箭头

顺序图中的逻辑结构

- opt：可选的内容

- alt：对分支条件的选择

- loop(start,end,condition)：对循环结构的定义

通信图：对对象之间动态的交互进行可视化建模

- 对象之间通过实线连接

- 连接的一侧描述消息的交互信息

- 交互顺序通过消息前的数字进行标识

#### 场景模拟

使用顺序图对活动图进行确认的方法

## 代码生成



## 类的详细设计

## 设计优化

设计原则+设计模式

目的：尽可能提升设计方案对变化的适应能力

### 设计优化思想

类图向程序实现过渡

#### 运行时的多态

多态的基本思想:对类中每个变量，在保证业务成功实现的前提下，尽量保持类型泛化的定义

🌟重写的要求

1. 重写的方法的输入范围要包含原输入区间
2. 结果输出区间是原输出区间的子集

优点：减少 switch 语句的使用

#### 耦合的消息链

功能方法的实现位置 → 影响对象间交互的复杂程度

改进方法：移动方法的位置，减轻管理类的负担

#### 狎昵关系

表现为高耦合，eg. 某个类高度关注另一个类的私有成员

改进方法：改进借口，该类的业务逻辑拆分出一部分给另一个类

#### 被拒绝的遗赠

在该类的基础上进行功能和结构的拓展

方式

1. 继承
2. 委托 ：新的类与原有类构成关联关系

#### 循环依赖

两个类处在不同的包中,并且具有双向导航的关联关系

解决办法：在包 A 中添加对 B1 的接口 IB1，该接口中含有所有 A1 需要的 B1 方法的定义

### 设计原则

#### 接口隔离原则（ISP）

1. 应尽量使用“接口继承”1，而非“实现继承”。接口关注对象的概貌，将对象中“不变”的信息抽象出来，不涉及细节，因此是“稳定”的。
2. 通过接口，只将需要的操作“暴露”给需要的类，而将不需要的操作隐藏起来。接口在这里充当类的视图。

#### 依赖倒置原则（DIP）

原则：应依赖于抽象，而不要依赖于具体

#### 开放封闭原则（OCP）

原则：模块对于拓展是开放的，对于修改是封闭的

OCP 是相对的，没有绝对符合 OCP 的设计，而且一个软件系统的所有模块不可能都满足 OCP

#### Liskov 替换原则（LSP）

原则：任何出现父类的地方都应该能使用子类对其进行无条件的替换

> 某个类更新后可以替换掉旧的类

做法：不将父类中子类不需要的函数暴露给子类

#### 单一职责原则（SRP）

设计类的功能应该只有一个

#### 合成/聚合服用原则（CARP）

应尽量使用合成/聚合形式的委托重用，尽量不使用继承重用

### 设计模式

相似的程序设计任务中经常出现的相同问题的解决方案。

分类：

- 创建模式：抽象工厂模式、单例模式

- 结构模式：适配器模式、桥模式、装饰模式、门面模式、代理模式

- 行为模式：观察者模式、策略模式、状态模式

#### 抽象工厂模式

设计一个工厂类，使得 new 操作完全封装在工厂内。

#### 单例模式

类似于静态类，只存在单一的实例

要求：

1. 类的所有 *构造方法都是私有的*

2. 提供一个公有的方法来获取实例

3. 类中的实例变量是私有的或受保护的

#### 适配器模式

把一个类的接口变换成该类期待的另一个接口

可以通过继承或委托的方式

#### 桥模式

抽象部分与实现部分分离

一个类具有两个维度的属性 → 一个维度用继承实现（抽象部分），另一个用成员变量实现（实现部分）

#### 装饰模式

以对客户端透明的方式拓展对象的功能

桥模式中的“抽象”和“实现”合二为一

#### 门面模式

外部与子系统之间通信必须通过一个统一的门面对象

一般只有一个门面类且是一个单例模式 → 门面 = 适配器

#### 代理模式

一般对有价值的资源进行管理

使实体类分辨不出代理对象与真实资源对象

#### 观察者模式

多个观察者对象同时监听某一个主题对象

对应 MVC 架构：

- 视图 → 观察者
- 模型 → 主题

#### 策略模式

同一问题不同算法，将算法进行抽象

#### 状态模式

策略模式的一种应用，允许一个对象在其内部状态改变时改变其行为

## 实现技术

重点关注那些与实现相关的关键技术及衍生内容

### 非功能性需求的实现

#### 硬件方面的需求

原型系统不太注重性能上的表现 → 难以在早期被发现

#### 质量方面的需求

即系统的正确性 → 主要在软件测试阶段处理

#### 安全方面的需求

- 特指授权安全性（Security）
- 数据存储安全性 （Safety）

### 分布式技术

程序中唯一的控制点 → 分布式系统中多个控制点

#### 进程之间信息交换方式

需要保证原子性 ，即保证，某一事务的执行不会对其他事物产生副作用

> eg.转账过程中，扣款和入账操作需要同时成功

临界区：为保证原子性，使某一进程不能被其他进程中断操作的范围

#### 进程间通信的不同形式

远程系统中方法的调用：可通过代理模式实现

远程对象调用的管理

- 每个对象都在其被创建的进程里管理，对对象方法的调用都要进行转发
- 将对象及其副本在网络节点上分布

同步调用和异步调用：信息发出后等待与否

同步调用中，有可能产生死锁

## 维护

基本任务：保证软件在一个相当长的时期能够正常运行

---

# 参考资料
- 《软件工程》 朴勇
- 《软件工程导论》 张海藩
- 大连理工大学软件学院 软件工程课程 课件 朴勇
